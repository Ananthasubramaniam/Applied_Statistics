# Q1: Compute the probability P(-1.25 < Z <= 2.10)
# Using pnorm()
prob_pnorm <- pnorm(2.10) - pnorm(-1.25)
print(paste("Probability using pnorm():", prob_pnorm))
# Using numerical integration
integrand <- function(x) {
dnorm(x)
}
prob_integrate <- integrate(integrand, lower = -1.25, upper = 2.10)$value
print(paste("Probability using integrate():", prob_integrate))
# Comparison
print(paste("Difference:", abs(prob_pnorm - prob_integrate)))
# Q2: Compute a 95% confidence interval for the true mean
x <- c(9.8, 10.1, 9.9, 10.2, 9.7, 10.0, 9.9, 9.8)
sigma <- 0.8
n <- length(x)
x_bar <- mean(x)
alpha <- 0.05
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * (sigma / sqrt(n))
confidence_interval <- c(x_bar - margin_of_error, x_bar + margin_of_error)
print("95% Confidence Interval:")
print(confidence_interval)
# Q10: Function to compute and plot two-sided p-value
plot_p_value <- function(z_scores) {
p_values <- 2 * (1 - pnorm(abs(z_scores)))
plot(z_scores, p_values, type = "l", main = "Two-sided p-value vs. Z-score", xlab = "Z-score", ylab = "p-value")
abline(h = 0.05, col = "red", lty = 2)
# Interpretation
cat("The plot shows the p-value for different Z-scores. The red dashed line represents an alpha level of 0.05.
Any Z-score where the p-value (black line) is below the red line would lead to rejecting the null hypothesis.
This corresponds to Z-scores with an absolute value greater than", qnorm(1 - 0.05 / 2), "\n")
}
z_scores <- seq(-3.5, 3.5, by = 0.1)
plot_p_value(z_scores)
# Q2: Compute a 95% confidence interval for the true mean
x <- c(9.8, 10.1, 9.9, 10.2, 9.7, 10.0, 9.9, 9.8)
sigma <- 0.8
n <- length(x)
x_bar <- mean(x)
alpha <- 0.05
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * (sigma / sqrt(n))
confidence_interval <- c(x_bar - margin_of_error, x_bar + margin_of_error)
print("95% Confidence Interval:")
print(confidence_interval)
# Q3: Compute a 98% confidence interval for the true defective proportion
# (a) using the Z-based manual formula
n <- 300
x <- 21
p_hat <- x / n
alpha <- 0.02
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * sqrt(p_hat * (1 - p_hat) / n)
confidence_interval_manual <- c(p_hat - margin_of_error, p_hat + margin_of_error)
print("98% Confidence Interval (Manual):")
print(confidence_interval_manual)
# (b) using prop.test(correct = FALSE)
prop_test_result <- prop.test(x, n, conf.level = 0.98, correct = FALSE)
confidence_interval_prop_test <- prop_test_result$conf.int
print("98% Confidence Interval (prop.test):")
print(confidence_interval_prop_test)
# Comparison
print("The manual formula and prop.test give very similar results. prop.test is generally preferred as it can handle more complex situations and provides more information.")
# Q4: Generate a table of critical Z-values for two-sided confidence levels
confidence_levels <- c(0.90, 0.95, 0.99, 0.995, 0.999)
alpha_levels <- 1 - confidence_levels
critical_z_values <- qnorm(1 - alpha_levels / 2)
results <- data.frame(
Confidence_Level = paste0(confidence_levels * 100, "%"),
Critical_Z_Value = critical_z_values
)
print("Critical Z-values for two-sided confidence levels:")
print(results)
# Q5: Perform a left-tailed Z-test
mu0 <- 1200
x_bar <- 1172
sigma <- 100
n <- 50
alpha <- 0.05
# Z-statistic
z_statistic <- (x_bar - mu0) / (sigma / sqrt(n))
print(paste("Z-statistic:", z_statistic))
# p-value
p_value <- pnorm(z_statistic)
print(paste("p-value:", p_value))
# Conclusion
if (p_value < alpha) {
print("Reject the null hypothesis. There is sufficient evidence to conclude that the mean lifetime of the battery is less than 1200 hours.")
} else {
print("Fail to reject the null hypothesis. There is not sufficient evidence to conclude that the mean lifetime of the battery is less than 1200 hours.")
}
# Q6: Two-sample Z-test
n1 <- 45
x1_bar <- 52.3
sigma1 <- 2.1
n2 <- 55
x2_bar <- 51.5
sigma2 <- 1.8
alpha <- 0.01
# Z-statistic
z_statistic <- (x1_bar - x2_bar) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
print(paste("Z-statistic:", z_statistic))
# p-value
p_value <- 2 * (1 - pnorm(abs(z_statistic)))
print(paste("p-value:", p_value))
# Conclusion
if (p_value < alpha) {
print("Reject the null hypothesis. There is a significant difference in the mean cable strength between the two factories.")
} else {
print("Fail to reject the null hypothesis. There is no significant difference in the mean cable strength between the two factories.")
}
# Q1: Compute the probability P(-1.25 < Z <= 2.10)
# Using pnorm()
prob_pnorm <- pnorm(2.10) - pnorm(-1.25)
print(paste("Probability using pnorm():", prob_pnorm))
# Using numerical integration
integrand <- function(x) {
dnorm(x)
}
prob_integrate <- integrate(integrand, lower = -1.25, upper = 2.10)$value
print(paste("Probability using integrate():", prob_integrate))
# Comparison
print(paste("Difference:", abs(prob_pnorm - prob_integrate)))
# Q1: Compute the probability P(-1.25 < Z <= 2.10)
# Using pnorm()
prob_pnorm <- pnorm(2.10) - pnorm(-1.25)
print(paste("Probability using pnorm():", prob_pnorm))
# Using numerical integration
integrand <- function(x) {
dnorm(x)
}
prob_integrate <- integrate(integrand, lower = -1.25, upper = 2.10)$value
print(paste("Probability using integrate():", prob_integrate))
# Comparison
print(paste("Difference:", abs(prob_pnorm - prob_integrate)))
# Q1: Compute the probability P(-1.25 < Z <= 2.10)
# Using pnorm()
prob_pnorm <- pnorm(2.10) - pnorm(-1.25)
print(paste("Probability using pnorm():", prob_pnorm))
# Using numerical integration
integrand <- function(x) {
dnorm(x)
}
prob_integrate <- integrate(integrand, lower = -1.25, upper = 2.10)$value
print(paste("Probability:", prob_integrate))
# Comparison
print(paste("Difference:", abs(prob_pnorm - prob_integrate)))
# Q2: Compute a 95% confidence interval for the true mean
x <- c(9.8, 10.1, 9.9, 10.2, 9.7, 10.0, 9.9, 9.8)
sigma <- 0.8
n <- length(x)
x_bar <- mean(x)
alpha <- 0.05
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * (sigma / sqrt(n))
confidence_interval <- c(x_bar - margin_of_error, x_bar + margin_of_error)
print("95% Confidence Interval:")
print(confidence_interval)
# Q3: Compute a 98% confidence interval for the true defective proportion
# (a) using the Z-based manual formula
n <- 300
x <- 21
p_hat <- x / n
alpha <- 0.02
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * sqrt(p_hat * (1 - p_hat) / n)
confidence_interval_manual <- c(p_hat - margin_of_error, p_hat + margin_of_error)
print("98% Confidence Interval (Manual):")
print(confidence_interval_manual)
# (b) using prop.test(correct = FALSE)
prop_test_result <- prop.test(x, n, conf.level = 0.98, correct = FALSE)
confidence_interval_prop_test <- prop_test_result$conf.int
print("98% Confidence Interval (prop.test):")
print(confidence_interval_prop_test)
# Comparison
print("The manual formula and prop.test give very similar results. prop.test is generally preferred as it can handle more complex situations and provides more information.")
# Q4: Generate a table of critical Z-values for two-sided confidence levels
confidence_levels <- c(0.90, 0.95, 0.99, 0.995, 0.999)
alpha_levels <- 1 - confidence_levels
critical_z_values <- qnorm(1 - alpha_levels / 2)
results <- data.frame(
Confidence_Level = paste0(confidence_levels * 100, "%"),
Critical_Z_Value = critical_z_values
)
print("Critical Z-values for two-sided confidence levels:")
print(results)
# Q5: Perform a left-tailed Z-test
mu0 <- 1200
x_bar <- 1172
sigma <- 100
n <- 50
alpha <- 0.05
# Z-statistic
z_statistic <- (x_bar - mu0) / (sigma / sqrt(n))
print(paste("Z-statistic:", z_statistic))
# p-value
p_value <- pnorm(z_statistic)
print(paste("p-value:", p_value))
# Conclusion
if (p_value < alpha) {
print("Reject the null hypothesis. There is sufficient evidence to conclude that the mean lifetime of the battery is less than 1200 hours.")
} else {
print("Fail to reject the null hypothesis. There is not sufficient evidence to conclude that the mean lifetime of the battery is less than 1200 hours.")
}
# Q5: Perform a left-tailed Z-test
mu0 <- 1200
x_bar <- 1172
sigma <- 100
n <- 50
alpha <- 0.05
# Z-statistic
z_statistic <- (x_bar - mu0) / (sigma / sqrt(n))
print(paste("Z-statistic:", z_statistic))
# p-value
p_value <- pnorm(z_statistic)
print(paste("p-value:", p_value))
# Conclusion
if (p_value < alpha) {
print("Reject the null hypothesis. There is sufficient evidence to conclude that the mean lifetime of the battery is less than 1200 hours.")
} else {
print("Fail to reject the null hypothesis. There is not sufficient evidence to conclude that the mean lifetime of the battery is less than 1200 hours.")
}
print(paste("Z-statistic:", z_statistic))
# Q6: Two-sample Z-test
n1 <- 45
x1_bar <- 52.3
sigma1 <- 2.1
n2 <- 55
x2_bar <- 51.5
sigma2 <- 1.8
alpha <- 0.01
# Z-statistic
z_statistic <- (x1_bar - x2_bar) / sqrt((sigma1^2 / n1) + (sigma2^2 / n2))
print(paste("Z-statistic:", z_statistic))
# p-value
p_value <- 2 * (1 - pnorm(abs(z_statistic)))
print(paste("p-value:", p_value))
# Conclusion
if (p_value < alpha) {
print("Reject the null hypothesis. There is a significant difference in the mean cable strength between the two factories.")
} else {
print("Fail to reject the null hypothesis. There is no significant difference in the mean cable strength between the two factories.")
}
# Q10
plot_p_value <- function(z_scores) {
p_values <- 2 * (1 - pnorm(abs(z_scores)))
plot(z_scores, p_values, type = "l", main = "Two-sided p-value vs. Z-score", xlab = "Z-score", ylab = "p-value")
abline(h = 0.05, col = "red", lty = 2)
# Interpretation
cat("The plot shows the p-value for different Z-scores. The red dashed line represents an alpha level of 0.05.
Any Z-score where the p-value (black line) is below the red line would lead to rejecting the null hypothesis.
This corresponds to Z-scores with an absolute value greater than", qnorm(1 - 0.05 / 2), "\n")
}
z_scores <- seq(-3.5, 3.5, by = 0.1)
plot_p_value(z_scores)
# Q10
# Q9: Monte-Carlo simulation to estimate beta
mu_true <- 105
sigma <- 15
n <- 36
mu0 <- 100
alpha <- 0.05
critical_x_bar <- mu0 + qnorm(1 - alpha) * (sigma / sqrt(n))
num_simulations <- 10000
samples <- rnorm(num_simulations * n, mean = mu_true, sd = sigma)
sample_means <- colMeans(matrix(samples, nrow = n))
# Estimate beta
beta_hat <- mean(sample_means <= critical_x_bar)
print(paste("Estimated beta from simulation:", beta_hat))
# Theoretical beta
beta_theoretical <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Theoretical beta:", beta_theoretical))
# Comparison
print(paste("Difference:", abs(beta_hat - beta_theoretical)))
# Q8: Right-tailed hypothesis test
mu0 <- 100
sigma <- 15
n <- 36
alpha <- 0.05
mu_true <- 105
# (a) Determine the critical region
critical_z <- qnorm(1 - alpha)
critical_x_bar <- mu0 + critical_z * (sigma / sqrt(n))
print(paste("Critical region: x_bar >", critical_x_bar))
# (b) Compute the Type-II error probability (beta)
beta <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Type-II error probability (beta):", beta))
# (c) Compute the Power of the test
power <- 1 - beta
print(paste("Power of the test:", power))
# Q7: Plot a standard normal curve and shade the rejection regions
alpha <- 0.05
critical_z <- qnorm(1 - alpha / 2)
x <- seq(-4, 4, length.out = 1000)
y <- dnorm(x)
plot(x, y, type = "l", main = "Standard Normal Curve with Rejection Regions", xlab = "Z", ylab = "Density")
# Shade rejection regions
x_reject_pos <- seq(critical_z, 4, length.out = 100)
y_reject_pos <- dnorm(x_reject_pos)
polygon(c(critical_z, x_reject_pos, 4), c(0, y_reject_pos, 0), col = "red")
x_reject_neg <- seq(-4, -critical_z, length.out = 100)
y_reject_neg <- dnorm(x_reject_neg)
polygon(c(-4, x_reject_neg, -critical_z), c(0, y_reject_neg, 0), col = "red")
# Label critical Z-values
text(critical_z, 0.05, paste("z =", round(critical_z, 2)), pos = 4)
text(-critical_z, 0.05, paste("z =", round(-critical_z, 2)), pos = 2)
# Q8: Right-tailed hypothesis test
mu0 <- 100
sigma <- 15
n <- 36
alpha <- 0.05
mu_true <- 105
# (a) Determine the critical region
critical_z <- qnorm(1 - alpha)
critical_x_bar <- mu0 + critical_z * (sigma / sqrt(n))
print(paste("Critical region: x_bar >", critical_x_bar))
# (b) Compute the Type-II error probability (beta)
beta <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Type-II error probability (beta):", beta))
# (c) Compute the Power of the test
power <- 1 - beta
print(paste("Power of the test:", power))
# Q9: Monte-Carlo simulation to estimate beta
mu_true <- 105
sigma <- 15
n <- 36
mu0 <- 100
alpha <- 0.05
critical_x_bar <- mu0 + qnorm(1 - alpha) * (sigma / sqrt(n))
num_simulations <- 10000
samples <- rnorm(num_simulations * n, mean = mu_true, sd = sigma)
sample_means <- colMeans(matrix(samples, nrow = n))
# Estimate beta
beta_hat <- mean(sample_means <= critical_x_bar)
print(paste("Estimated beta from simulation:", beta_hat))
# Theoretical beta
beta_theoretical <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Theoretical beta:", beta_theoretical))
# Comparison
print(paste("Difference:", abs(beta_hat - beta_theoretical)))
# Q9: Monte-Carlo simulation to estimate beta
mu_true <- 105
sigma <- 15
n <- 36
mu0 <- 100
alpha <- 0.05
critical_x_bar <- mu0 + qnorm(1 - alpha) * (sigma / sqrt(n))
num_simulations <- 10000
samples <- rnorm(num_simulations * n, mean = mu_true, sd = sigma)
sample_means <- colMeans(matrix(samples, nrow = n))
# Estimate beta
beta_hat <- mean(sample_means <= critical_x_bar)
print(paste("Estimated beta from simulation:", beta_hat))
# Theoretical beta
beta_theoretical <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Theoretical beta:", beta_theoretical))
# Comparison
print(paste("Difference:", abs(beta_hat - beta_theoretical)))
# Q8: Right-tailed hypothesis test
mu0 <- 100
sigma <- 15
n <- 36
alpha <- 0.05
mu_true <- 105
# (a) Determine the critical region
critical_z <- qnorm(1 - alpha)
critical_x_bar <- mu0 + critical_z * (sigma / sqrt(n))
print(paste("Critical region: x_bar >", critical_x_bar))
# (b) Compute the Type-II error probability (beta)
beta <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Type-II error probability (beta):", beta))
# (c) Compute the Power of the test
power <- 1 - beta
print(paste("Power of the test:", power))
# Q9: Monte-Carlo simulation to estimate beta
mu_true <- 105
sigma <- 15
n <- 36
mu0 <- 100
alpha <- 0.05
critical_x_bar <- mu0 + qnorm(1 - alpha) * (sigma / sqrt(n))
num_simulations <- 10000
samples <- rnorm(num_simulations * n, mean = mu_true, sd = sigma)
sample_means <- colMeans(matrix(samples, nrow = n))
# Estimate beta
beta_hat <- mean(sample_means <= critical_x_bar)
print(paste("Estimated beta from simulation:", beta_hat))
# Theoretical beta
beta_theoretical <- pnorm((critical_x_bar - mu_true) / (sigma / sqrt(n)))
print(paste("Theoretical beta:", beta_theoretical))
# Comparison
print(paste("Difference:", abs(beta_hat - beta_theoretical)))
# Q10: Function to compute and plot two-sided p-value
plot_p_value <- function(z_scores) {
p_values <- 2 * (1 - pnorm(abs(z_scores)))
plot(z_scores, p_values, type = "l", main = "Two-sided p-value vs. Z-score", xlab = "Z-score", ylab = "p-value")
abline(h = 0.05, col = "red", lty = 2)
# Interpretation
cat("The plot shows the p-value for different Z-scores. The red dashed line represents an alpha level of 0.05.
Any Z-score where the p-value (black line) is below the red line would lead to rejecting the null hypothesis.
This corresponds to Z-scores with an absolute value greater than", qnorm(1 - 0.05 / 2), "\n")
}
z_scores <- seq(-3.5, 3.5, by = 0.1)
plot_p_value(z_scores)
# Q3: Compute a 98% confidence interval for the true defective proportion
# (a) using the Z-based manual formula
n <- 300
x <- 21
p_hat <- x / n
alpha <- 0.02
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * sqrt(p_hat * (1 - p_hat) / n)
confidence_interval_manual <- c(p_hat - margin_of_error, p_hat + margin_of_error)
print("98% Confidence Interval (Manual):")
print(confidence_interval_manual)
# (b) using prop.test(correct = FALSE)
prop_test_result <- prop.test(x, n, conf.level = 0.98, correct = FALSE)
confidence_interval_prop_test <- prop_test_result$conf.int
print("98% Confidence Interval (prop.test):")
print(confidence_interval_prop_test)
# Comparison
print("The manual formula and prop.test give very similar results. prop.test is generally preferred as it can handle more complex situations and provides more information.")
# Q3: Compute a 98% confidence interval for the true defective proportion
# (a) using the Z-based manual formula
n <- 300
x <- 21
p_hat <- x / n
alpha <- 0.02
z_alpha_by_2 <- qnorm(1 - alpha / 2)
margin_of_error <- z_alpha_by_2 * sqrt(p_hat * (1 - p_hat) / n)
confidence_interval_manual <- c(p_hat - margin_of_error, p_hat + margin_of_error)
print("98% Confidence Interval (Manual):")
print(confidence_interval_manual)
# (b) using prop.test(correct = FALSE)
prop_test_result <- prop.test(x, n, conf.level = 0.98, correct = FALSE)
confidence_interval_prop_test <- prop_test_result$conf.int
print("98% Confidence Interval (prop.test):")
print(confidence_interval_prop_test)
# Comparison
print("The manual formula and prop.test give very similar results")
# Q4: Generate a table of critical Z-values for two-sided confidence levels
confidence_levels <- c(0.90, 0.95, 0.99, 0.995, 0.999)
alpha_levels <- 1 - confidence_levels
critical_z_values <- qnorm(1 - alpha_levels / 2)
results <- data.frame(
Confidence_Level = paste0(confidence_levels * 100, "%"),
Critical_Z_Value = critical_z_values
)
print("Critical Z-values for two-sided confidence levels:")
print(results)
